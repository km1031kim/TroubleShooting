## 1. 컴팩션 필요 여부 확인 주기

<img width="1385" height="350" alt="image" src="https://github.com/user-attachments/assets/6f977f72-8ac8-47a6-ae05-858f6e59a17e" />

리전서버당 `CompactionChecker` 내부 정적 클래스가 존재한다.

해당 클래스는 `initializeThreads`  에서 생성되며, 스레드 실행 주기도 함께 생성자로 전달된다.  
#
&nbsp;<img width="971" height="276" alt="image" src="https://github.com/user-attachments/assets/52543bd9-5408-4a64-9eec-286b906b3016" />
&nbsp;<img width="1309" height="164" alt="image" src="https://github.com/user-attachments/assets/5bc5a3a5-a74e-4419-a584-2640efe52a32" />
sleepTime 주기로 `CompactionChecker` 클래스의 `run()`이 수행되며 <br> 


   






		
<img width="1112" height="60" alt="image" src="https://github.com/user-attachments/assets/6b25631f-d0be-43f5-ba5d-ed0a4f18e405" />


	
	
sleepTime값으로 전달된 `compationCheckFrequency`는 위 설정을 따라간다. <br>  

<img width="371" height="92" alt="image" src="https://github.com/user-attachments/assets/3c7e69d5-f346-434d-a8ec-323d1ed2eb0d" />

`hbase.server.thread.wakefrequency` 기본값이 이미 지정된 상태.

위에서 지정한 sleepTime에 따라, 10초마다 `CompactionChecker`의 `run()` 이 실행되고,

`run()` → `chore()` 를 호출한다. <br>  









	

- `run()` → `chore()` 호출

  
<img width="886" height="599" alt="image" src="https://github.com/user-attachments/assets/ab38f31f-07cf-43b8-9f17-870b28a4a6ac" />




<br> 
		
- `chore()` 내부에서 컴팩션 필요 여부 판단

	
<img width="886" height="599" alt="image" src="https://github.com/user-attachments/assets/a1ff87fa-d105-4ebd-9875-0bb9a8609fb6" />


`multiplier` 값은 `s.getCompactionCheckMultiplier()` 실행 결과이고, 해당 값은 
`hbase.server.compactchecker.interval.multiplier` 설정을 따라간다.<br> 
<img width="523" height="92" alt="image" src="https://github.com/user-attachments/assets/239dfbae-fcab-4d46-856f-b5f78cbf7ba2" />


`multiplier` 값은 1000이 기본값이다.

if 문 내부에 진입하기 위해서는 `iteration` 값이 `multiplier` 값의 배수여야 한다.

if 문 내부에 진입하지 못한다면 `iteration` 값을 1 증가시키고 `chore()` 가 종료되는데,

위 설정에 따르면 약 2시간 46 주기로 `chore()` 메서드가 1000번 실행되고, 

`iteration` 값이 1000의 배수가 됨에 따라 if 문 내부에 진입한다

→ `CompactionChecker` 클래스의 `chore()`는 10초마다 실행되지만, 실제 CF 단위 compaction 판단은 약 2시간 46분 주기로 수행된다

---

## 2. 컴팩션 필요 여부 확인 및 요청

1. 마이너 컴팩션 여부 확인.
2. 마이너 컴팩션이 필요 없다면, 메이저 컴팩션 주기를 확인한다.

마이너 컴팩션 필요에 따라 컴팩션이 요청된다고 하더라도, 내부적으로 메이저 컴팩션으로 동작할 수 있다.

<img width="1168" height="583" alt="image" src="https://github.com/user-attachments/assets/ae8e3ce8-89bd-46e6-93e5-c286a76ee916" />

HStore는 리전 내의 컬럼 패밀리를 뜻한다.

각각의 컬럼 패밀리에 대해 컴팩션 필요 여부를 확인하는데 먼저 `s.needsCompaction()`이 호출된다.

컬럼 패밀리의 컴팩션 필요 여부를 확인한다.<br> 


<img width="651" height="326" alt="image" src="https://github.com/user-attachments/assets/8214deef-49bb-473b-be52-86563f1f5ab7" />


`numCandidates` = 전체 스토어파일 수 - 현재 컴팩션 진행 중이거나, 컴팩션 예정인 파일 수

위 값이 `comConf.getMinFilesToCompact()` 이상이어야 한다.

`getMinFilesToCompact()` 값은 `hbase.hstore.compactionThreshold`  에서 가져온다.
<img width="412" height="93" alt="image" src="https://github.com/user-attachments/assets/40fc779d-bbca-4306-8093-32ebe677f0e0" />


위 설정에 따르면 계산 결과값이 3 이상이면 컴팩션이 필요하다고 판단한다

마이너, 메이저 구분은 이후에 결정된다.
<img width="1071" height="86" alt="image" src="https://github.com/user-attachments/assets/8ae04b09-0986-44d3-acec-12507dafe41a" />
true 반환 시 시스템 컴팩션이 수행된다. 

시스템 컴팩션의 우선순위는 `NO_PRIORITY`로써, `Integer.MIN_VALUE` 값으로 적용된다. <br> 
<img width="1040" height="218" alt="image" src="https://github.com/user-attachments/assets/9d00f0c2-f03b-407a-90ef-94ec3c383a37" />


스토어파일 수가 충분히 줄어 else if 로 빠지는 경우 `shouldPerformMajorCompaction` 메서드가 수행되는데 여기서 메이저 컴팩션 주기를 확인한다.

<img width="878" height="309" alt="image" src="https://github.com/user-attachments/assets/9bf54072-bd4f-412e-b319-8ca14c72b6d9" />

<br> 
<img width="858" height="103" alt="image" src="https://github.com/user-attachments/assets/768b4ae6-ee7b-4059-8864-33b6b3c41d03" />


`getNextMajorCompactTime`  메서드는 위 설정값에 jitter를 곱한 값으로 지정된다.
<br> 
<img width="866" height="228" alt="image" src="https://github.com/user-attachments/assets/f73201d6-a160-47c7-b8e2-66cd51d2384a" />


7일 주기인 경우 3.5일 ~ 10.5일 사이에서 랜덤으로 지정된다.
<br> 
<img width="910" height="675" alt="image" src="https://github.com/user-attachments/assets/326fa053-d155-460c-9faa-c0e5d1347152" />


`shouldPerformMajorCompaction` 메서드는 메이저 컴팩션 주기 뿐만 아니라 여러 조건들을 확인한다.

컴팩션 대상 파일 수가 하나라면 블록 로컬리티도 임계치에 맞게 조정한다.

---

## 3. 마이너/메이저 컴팩션 결정

`SortedCompactionPolicy` 클래스에서 마이너, 메이저 컴팩션을 결정한다.
<br> 
<img width="893" height="749" alt="image" src="https://github.com/user-attachments/assets/978ba282-e9e2-4b84-9f66-b877c495d7b6" />

`isUserCompaction`은 유저가 직접 메이저 컴팩션을 요청해야 `true`로 설정된다.

위 코드를 기반으로 살펴보면,

모든 파일을 합치는 메이저 컴팩션의 경우 유저가 요청한 메이저 컴팩션이어야 한다.

시스템이 메이저 컴팩션이 필요하다고 결정하는 경우, 부분적으로 메이저 컴팩션이 일어난다.
<br> 
<img width="912" height="143" alt="image" src="https://github.com/user-attachments/assets/865b7410-a3d4-4c73-bd39-57c534f818c8" />


isTryingMajor는 메이저 컴팩션으로 동작할지 여부를 결정하는 플래그다.

조건은, 유저가 요청한 메이저 컴팩션 Or 시스템이 판단한 메이저 컴팩션 필요 여부

시스템에서 메이저 컴팩션 수행이 필요하다고 판단하려면 `shouldPerformMajorCompaction` 및 `candidateSelection.size()` 의 두 가지 조건을 모두 만족해야한다.

`shouldPerformMajorCompaction` 에서는 

1. 마지막 메이저 컴팩션 시간을 확인해서, 그 주기가 돌아왔는지 확인하고.
2. 컴팩션 대상 스토어파일 수가 `comConf.getMaxFilesToCompact()` 보다 작아야 하는데, 이 값은 
`hbase.hstore.compaction.max` 에서 가져온다.
<br> 
<img width="330" height="95" alt="image" src="https://github.com/user-attachments/assets/8b90a7e6-c757-4ba1-8d35-20fd34ed5caa" />


즉 시스템에서 메이저 컴팩션이 필요하다고 결정되려면, 메이저 컴팩션 주기가 돌아와야하고, 스토어파일 수가 `hbase.hstore.compaction.max` 보다 작아야 한다. 
<br> 
<img width="739" height="143" alt="image" src="https://github.com/user-attachments/assets/a49d1a4a-85b9-4068-ac53-efc247b8381e" />


이후 `CompactionRequest` 객체를 만드는데, 이 때 컬럼패밀리 내부에 참조 스토어파일이 있는 경우 `tryingMajor`가 `true`로 전달되어 메이저 컴팩션으로 동작한다.
<br> 
<img width="858" height="375" alt="image" src="https://github.com/user-attachments/assets/f88e4d63-89f6-4750-870e-33da91a95462" />


이후 위에서 살펴본 `hbase.hstore.compaction.max` 값만큼 컴팩션 대상 스토어파일 수를 자른다.

하지만 유저가 요청한 메이저 컴팩션의 경우 자르지 않고 모든 파일을 하나로 합친다.

즉, 시스템이 메이저 컴팩션이 필요하여 요청한다고 하더라도 모든 파일을 합치지는 않는다.

(최대 `hbase.hstore.compaction.max` 만큼의 파일을 하나로 합침)
<br> 
- 문제가 됐던 여러 테이블 중 하나의 스토어파일 목록

<img width="1472" height="633" alt="image" src="https://github.com/user-attachments/assets/c3d6d386-8ea1-4eb3-88e2-cb26a917ec0b" />


위 테이블의 경우,

20T 단일 스토어파일과, 여러 참조 스토어파일로 이루어져 있었는데,

이 테이블의 경우 스토어(컬럼 패밀리)에 참조 스토어파일이 있어서 `tryingMajor = true`로 변경었을거고

유저가 요청한 컴팩션이 아니기에 `removeExcessFiles` 메서드에서  `comConf.getMaxFilesToCompact()` 

값 만큼 스토어파일이 subList 되어 부분적으로 메이저 컴팩션이 실행되었을 걸로 추정된다.

테라바이트 단위의 스토어파일이 생기는 이유는,

```java
# 크기가 큰 리전 start key / end key
P_M_2V2_M30S20_A_I_20240319_221644_00000@P300709_00021745_15_srcimg_1997 
P_M_2V2_M30S20_A_I_20241005_025246_00000@P300709_00031156_08_srcimg_3242
```

타임스탬프 기반 RowKey로 인해 항상 테이블의 마지막 리전에 write가 집중된다.

이로 인해 flush가 반복적으로 발생하며 일정 크기의 StoreFile이 다수 생성된다.

StoreFile 수가 증가하면 `hbase.hstore.blockingStoreFiles` 기준을 초과하게 되고,

HBase는 split보다 compaction을 우선해야 하는 상태로 판단하여

system compaction을 재귀적으로 요청하며 split은 지속적으로 지연된다.

즉, 컴팩션이 파일을 “줄이는 속도”보다, flush가 파일을 “만드는 속도”가 더 빠르다.

그래서 compaction → split으로 못 가고 계속 compaction에 묶이는 상태 지속.

결과적으로 크기가 큰 스토어파일 생성.

---

## 4. 컴팩션 대상 파일 셀렉트

`RatioBasedCompactionPolicy` 에서 컴팩션 대상 파일을 선정하는 로직을 확인할 수 있다.
<br> 
<img width="1423" height="325" alt="image" src="https://github.com/user-attachments/assets/c598929c-2fdd-4d2c-835b-b08aa3f69908" />


`tryingMajor` 값은 유저가 요청한 메이저 컴팩션이거나, 참조가 존재하는 컬럼패밀리의 경우 `true`로 전달되는데, 이 경우에는 별도의 파일 선정을 하지 않는다.

`tryingMajor` 가 false인 경우 if 문 내부로 진입해서 파일 크기를 비교하는 로직이 실행된다.

스토어파일을 합침으로써 얻는 이득을 계산한다.
<br> 
<img width="869" height="918" alt="image" src="https://github.com/user-attachments/assets/45709d45-1d86-4024-b7d9-57fef8cf20ef" />


아래 표에서 살펴보면,

| 파일 이름 | 크기 (Size(F)) | 생성 순서 (오래됨 → 최신) |
| --- | --- | --- |
| F1 | 10 MB | 1st (가장 오래됨) |
| F2 | 10 MB | 2nd |
| F3 | 20 MB | 3rd |
| F4 | 50 MB | 4th |
| F5 | 100 MB | 5th |
| F6 | 120 MB | 6th |
| F7 | 10 MB | 7th (가장 최신) |
<br> 
<img width="665" height="467" alt="image" src="https://github.com/user-attachments/assets/878641bb-edf2-4825-938c-b13c80d40cfc" />


파일을 합침으로써 얻는 이득을 생각하는 로직이다.

여기서 `hbase.hstore.compaction.ratio` 값이 사용된다.
<br> 
<img width="346" height="88" alt="image" src="https://github.com/user-attachments/assets/b96aa8da-13c0-4d27-9e03-3f00ba06db62" />


용량이 큰 단일 스토어파일의 경우 나머지 스토어파일들의 합 * ratio 값이 해당 단일 스토어파일보다 커야

컴팩션 대상으로 선정된다. 

→ 큰 스토어파일은 오랫동안 합쳐지지 않을 수 있음.
<br> 
<img width="423" height="90" alt="image" src="https://github.com/user-attachments/assets/65fcf449-f353-406e-a4c3-7b426cd436b5" />


`hbase.hstore.compaction.min.size` 값 이하의 스토어파일들은 위의 ratio 정책을 적용하지 않고, 컴팩션 대상으로 바로 집어넣는다. 해당 설정값보다 큰 스토어파일만 위 로직을 탄다.

---

## 5. 리전 스플릿 조건

### 조건0. 컴팩션이 호출되지 않으면 스플릿도 호출되지 않는다.
<br> 
<img width="1131" height="587" alt="image" src="https://github.com/user-attachments/assets/68df7994-0a2f-4b26-89e6-15e5b5daf1c9" />


`s.needsCompaction() == false`

`s.shouldPerformMajorCompaction() == false` 라면

아무 동작도 일어나지 않는다.
<br> 
<img width="393" height="92" alt="image" src="https://github.com/user-attachments/assets/68310e2d-98a1-4fd4-86a4-0d16162f5fcc" />


`hbase.hstore.compactionThreshold` (minFilesToCompact) 값이 3 이면,

3 보다 작은 스토어파일 수를 가진 스토어(컬럼 패밀리)는 `s.shouldPerformMajorCompaction()` 로 메이저 컴팩션 여부를 확인한다.

이전 메이저 컴팩션 시간을 보고, 주기가 아직 돌아오지 않아 메이저도 필요 없으면 그냥 `chore()` 종료

→ split도 호출 안 됨

### 조건1. `hbase.hstore.blockingStoreFiles` 값보다 스토어파일 갯수가 적어야한다.
<br> 
<img width="697" height="237" alt="image" src="https://github.com/user-attachments/assets/8d4bf407-2a43-4e74-ab73-784a106a20bd" />


컴팩션 종료 후 스토어(컬럼 패밀리)의 priority를 확인한다.

이 값이 1 이상이여야 스플릿이 호출된다.

0 이하일 경우 스플릿보다 컴팩션이 우선이라고 판단하여 재귀적으로 스플릿을 요청한다.
<br> 
<img width="737" height="157" alt="image" src="https://github.com/user-attachments/assets/47b61725-6b1a-42f5-9386-4672c1a371cd" />


priority 값은 `blockingFileCount - storefiles.size()` 으로 결정된다.
<br> 
<img width="385" height="88" alt="image" src="https://github.com/user-attachments/assets/dcc99dd2-b7e7-446a-b859-28e993e9c1a2" />


`hbase.hstore.blockingStoreFiles` 설정값 - 단일 컬럼 패밀리에 존재하는 스토어파일 수 

위 값이 음수인 경우, 스토어파일이 임계치보다 많은 상태로 판단, 

컴팩션 먼저 수행하여 파일을 줄여야 한다고 판단하여 시스템 컴팩션이 재귀적으로 호출된다.

### 조건 2. `hr.getCompactPriority() >= PRIORITY_USER)`
<br> 
<img width="962" height="448" alt="image" src="https://github.com/user-attachments/assets/d4cd10b0-55cc-43ea-8d38-dc6b5386d907" />


`requestSplit()` 메서드가 실행됬다는 건, `CompactionPriority`가 양수라는 것.

즉 위의 조건1 에 부합하는 상황이다.

if 문 우측 조건인 `hr.getCompactPriority() >= PRIORITY_USER` 부터 살펴보면,
<br> 
<img width="702" height="163" alt="image" src="https://github.com/user-attachments/assets/277eedf1-4fba-4b2a-b602-6fd0e25fbdcd" />


`hr.getCompactPriority`는 스토어(컬럼 패밀리)에서 가장 작은 priority를 가져온다.

가져온 priority가 PRIORITY_USER 값인 1 이상이여야 하는데

즉 스토어(컬럼 패밀리) 모두가 조건1 에 부합하여야 한다.

하지만 현재는 스토어 하나만 쓰니까 의미 없다. `shouldSplitRegion()` 만 따지면 된다.

### 조건3. `shouldSplitRegion`() : 리전 갯수 임계치 확인
<br> 
<img width="941" height="193" alt="image" src="https://github.com/user-attachments/assets/24667d96-f09d-4e77-87fe-7ee7b017d685" />


위 메서드가 true를 반환하려면 리전 개수가 임계치 아래여야 한다.
<br> 
<img width="395" height="90" alt="image" src="https://github.com/user-attachments/assets/fcba8360-8777-4c61-8d4e-ea2bc42e7574" />


온라인 리전 수가 0.9 * `hbase.regionserver.regionSplitLimit` 값을 초과하는 경우 WARN 로깅. 
`hbase.regionserver.regionSplitLimit` 값을 초과하는 경우 false 반환, 자동 스플릿 X
<br> 
<img width="829" height="687" alt="image" src="https://github.com/user-attachments/assets/8d65b70b-36f3-4b9b-8d9e-aad213f7a855" />


이후에는 스플릿 대상 리전이 충분히 큰지 확인한다.

특이한 점이, 같은 테이블에 속한 리전들의 크기를 보고 점진적으로 스플릿 기준 크기를 증가시킨다는 점.
<br> 
<img width="786" height="262" alt="image" src="https://github.com/user-attachments/assets/8e31f3d6-5f5f-4b31-9d06-d650ce032d74" />


같은 테이블에 속한 리전들이 많아지게 되면 Math.min에 따라 결국 `hbase.hregion.max.filesize` 로 최대값이 정해진다.

---

## 6. 스플릿 포인트 계산
<br> 
<img width="918" height="560" alt="image" src="https://github.com/user-attachments/assets/5e51d357-15c8-4bf2-b051-89d818f31d93" />


가장 큰 스토어파일을 찾아 그 중간 키를 반환한다.

스토어별로 가장 큰 스토어파일을 찾고, 그 스토어파일의 중간 키를 반환한다.

수동으로 스플릿 키 지정 시 -> 계산하지 않고 `getExplicitSplitPoint` 반환.

---

## 7. 스플릿 유저 직접 호출
<br> 
<img width="890" height="812" alt="image" src="https://github.com/user-attachments/assets/ab4e925b-a17f-4d32-8652-e07dd0c00c6c" />


- 유저 직접 호출 시 force true 반환
<br> 
<img width="455" height="82" alt="image" src="https://github.com/user-attachments/assets/99db0992-e0d8-4f20-b487-df4044e32249" />

<br> 
- 사용자가 직접 미드키를 명시하는 경우 `explicitSplitPoint` 반환.

<img width="912" height="623" alt="image" src="https://github.com/user-attachments/assets/13dc1267-0447-4f41-a33c-02f1f9b19a6d" />

<br> 
<img width="708" height="227" alt="image" src="https://github.com/user-attachments/assets/5a44cc8c-1501-404c-b024-57172040c100" />


사용자가 직접 split point를 명시하는 경우, `forceSplit` 메서드 호출.

내부에서 `explicitSplitPoint` 설정.
